#!/usr/bin/env python3
"""Git post-commit hook: Link commits to decisions.

This hook runs after a commit is created and attempts to link the commit
to any associated Membria decisions. It extracts decision IDs from:
1. Commit message (Membria Decision: dec_xxx pattern)
2. Current branch name (if it matches decision pattern)
3. Recent outcome tracking state

Usage:
  Place this file in .git/hooks/post-commit and make executable.
  Or call: membria hook post-commit
"""

import os
import sys
import subprocess
import json
from pathlib import Path

def get_current_commit_sha():
    """Get the SHA of the commit that was just created."""
    try:
        output = subprocess.check_output(
            ["git", "rev-parse", "HEAD"],
            text=True,
            stderr=subprocess.DEVNULL,
        )
        return output.strip()
    except Exception:
        return None


def get_commit_message(commit_sha):
    """Get the commit message for a given SHA."""
    try:
        output = subprocess.check_output(
            ["git", "log", "-1", "--pretty=%B", commit_sha],
            text=True,
            stderr=subprocess.DEVNULL,
        )
        return output.strip()
    except Exception:
        return None


def extract_decision_id_from_message(message):
    """Extract decision ID from commit message.

    Looks for patterns like:
    - Membria Decision: dec_123
    - Decision: dec_123
    """
    import re

    patterns = [
        r"Membria Decision:\s*(dec_[a-zA-Z0-9_]+)",
        r"Decision:\s*(dec_[a-zA-Z0-9_]+)",
        r"\[dec_[a-zA-Z0-9_]+\]",
    ]

    for pattern in patterns:
        match = re.search(pattern, message, re.IGNORECASE)
        if match:
            return match.group(1)

    return None


def get_current_branch():
    """Get current branch name."""
    try:
        output = subprocess.check_output(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"],
            text=True,
            stderr=subprocess.DEVNULL,
        )
        return output.strip()
    except Exception:
        return None


def extract_decision_id_from_branch(branch):
    """Extract decision ID from branch name.

    Looks for patterns like:
    - dec_123_feature_name
    - decision/dec_123
    """
    import re

    patterns = [
        r"dec_[a-zA-Z0-9_]+",
        r"decision/([a-zA-Z0-9_]+)",
    ]

    for pattern in patterns:
        match = re.search(pattern, branch, re.IGNORECASE)
        if match:
            # Return full match for first pattern, captured group for second
            return match.group(0) if match.groups() == () else match.group(1)

    return None


def find_decision_id():
    """Find decision ID from commit context."""
    commit_sha = get_current_commit_sha()
    if not commit_sha:
        return None

    # Try to extract from commit message
    message = get_commit_message(commit_sha)
    if message:
        decision_id = extract_decision_id_from_message(message)
        if decision_id:
            return decision_id

    # Try to extract from branch name
    branch = get_current_branch()
    if branch:
        decision_id = extract_decision_id_from_branch(branch)
        if decision_id:
            return decision_id

    return None


def main():
    """Main hook logic."""
    # Silently exit if we're in a non-git context
    try:
        subprocess.run(
            ["git", "rev-parse", "--git-dir"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True,
        )
    except Exception:
        return 0

    try:
        commit_sha = get_current_commit_sha()
        decision_id = find_decision_id()

        if commit_sha and decision_id:
            # Log to file (since we can't reliably output in a hook)
            hook_log = Path.home() / ".membria" / "hook_log.txt"
            hook_log.parent.mkdir(exist_ok=True, parents=True)

            with open(hook_log, "a") as f:
                f.write(f"Commit {commit_sha[:8]} linked to {decision_id}\n")

            # Try to notify daemon if it's running
            # (This is a soft failure - hook shouldn't crash if daemon is down)
            try:
                notify_daemon(commit_sha, decision_id)
            except Exception:
                pass  # Silently fail

    except Exception as e:
        # Log errors but never fail the hook
        try:
            hook_log = Path.home() / ".membria" / "hook_errors.txt"
            hook_log.parent.mkdir(exist_ok=True, parents=True)
            with open(hook_log, "a") as f:
                f.write(f"Error in post-commit hook: {e}\n")
        except Exception:
            pass

    return 0


def notify_daemon(commit_sha, decision_id):
    """Notify Membria daemon about new commit.

    Args:
        commit_sha: Commit SHA
        decision_id: Associated decision ID
    """
    # This would connect to the membria daemon via IPC/socket
    # For now, just a placeholder for the notification mechanism
    pass


if __name__ == "__main__":
    sys.exit(main())
